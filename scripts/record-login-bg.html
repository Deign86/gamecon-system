<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>PlayVerse — Login Background Recorder</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #080808;
      color: #ccc;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    #controls {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      padding: 20px;
      text-align: center;
      background: linear-gradient(to bottom, rgba(8,8,8,0.95) 60%, transparent);
    }
    h1 {
      color: #C8102E;
      font-size: 13px;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      margin-bottom: 6px;
    }
    #status {
      font-size: 11px;
      color: #888;
      margin-bottom: 14px;
    }
    button {
      background: #C8102E;
      color: #fff;
      border: none;
      padding: 10px 28px;
      font-family: inherit;
      font-size: 12px;
      letter-spacing: 0.15em;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.2s;
    }
    button:hover { background: #E31837; }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    #progressWrap {
      width: 240px;
      height: 3px;
      background: #1a1a1a;
      margin: 14px auto 0;
      border-radius: 2px;
      overflow: hidden;
    }
    #progressBar {
      height: 100%;
      width: 0%;
      background: #C8102E;
      transition: width 0.15s linear;
    }
    canvas {
      display: block;
      margin-top: 100px;
      border: 1px solid #1a1a1a;
    }
    .note {
      font-size: 10px;
      color: #555;
      margin-top: 16px;
      max-width: 500px;
      text-align: center;
      line-height: 1.6;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h1>▸ PlayVerse Login BG Recorder</h1>
    <p id="status">Preview active — press Record to capture one seamless loop</p>
    <button id="btn">● Record Loop</button>
    <div id="progressWrap"><div id="progressBar"></div></div>
  </div>

  <canvas id="canvas" width="1920" height="1080"></canvas>

  <p class="note">
    Records a 1920×1080 WebM video at 60 fps (frame-by-frame, no drops).<br>
    One full cycle = 400 frames ≈ 6.7 s for a seamless loop.<br>
    After download, move <code>login-bg.webm</code> into <code>public/</code>.
  </p>

<script>
// ─── Config ────────────────────────────────────────────────
const W = 1920, H = 1080;
const FPS             = 60;
const FRAME_DT        = 1 / FPS;                      // 0.01667 s per frame
const SHADER_SPEED    = 3.0;                           // shader-time units per real second
const LOOP_SHADER_T   = 20.0;                          // shader-time for one fract() cycle (1 / 0.05)
const LOOP_SECONDS    = LOOP_SHADER_T / SHADER_SPEED;  // ≈ 6.667 s
const TOTAL_FRAMES    = Math.round(LOOP_SECONDS * FPS);// 400 frames
const VIDEO_BITRATE   = 16_000_000;                    // 16 Mbps — high quality

// ─── WebGL bootstrap ──────────────────────────────────────
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl', {
  antialias: false,
  preserveDrawingBuffer: true,
  powerPreference: 'high-performance',
});

if (!gl) {
  document.getElementById('status').textContent =
    'ERROR: WebGL not supported in this browser.';
  throw new Error('No WebGL');
}

// ─── Shaders ──────────────────────────────────────────────
function compileShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    throw new Error('Shader compile failed');
  }
  return s;
}

const vs = compileShader(gl.VERTEX_SHADER, `
  attribute vec2 position;
  void main() { gl_Position = vec4(position, 0.0, 1.0); }
`);

const fs = compileShader(gl.FRAGMENT_SHADER, `
  precision highp float;
  uniform vec2  resolution;
  uniform float time;

  void main(void) {
    vec2 uv = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);
    float t = time * 0.05;
    float lineWidth = 0.006;

    // ── Base pattern (3-channel offset for subtle chromatic depth) ──
    vec3 raw = vec3(0.0);
    for (int j = 0; j < 3; j++) {
      for (int i = 0; i < 5; i++) {
        raw[j] += lineWidth * float(i * i)
          / abs(
              fract(t - 0.01 * float(j) + float(i) * 0.01) * 5.0
              - length(uv)
              + mod(uv.x + uv.y, 0.2)
            );
      }
    }

    // ── Crimson tint  (#C8102E → 200/255, 16/255, 46/255) ──
    vec3 color = vec3(
      raw.r * 1.6,
      raw.g * 0.06,
      raw.b * 0.28
    );

    // Moderate boost — visible rings on dark background
    color *= 4.5;

    // ── Vignette — darken edges, focus glow toward centre ──
    float vig = 1.0 - smoothstep(0.4, 1.8, length(uv));
    color *= mix(0.15, 1.0, vig);

    gl_FragColor = vec4(color, 1.0);
  }
`);

const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
  throw new Error('Program link failed: ' + gl.getProgramInfoLog(prog));
}
gl.useProgram(prog);

// ─── Geometry (full-screen quad) ──────────────────────────
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER,
  new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(prog, 'position');
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const uRes  = gl.getUniformLocation(prog, 'resolution');
const uTime = gl.getUniformLocation(prog, 'time');
gl.uniform2f(uRes, W, H);
gl.viewport(0, 0, W, H);

// ─── Render one frame at a deterministic shader time ──────
function renderFrame(shaderT) {
  gl.uniform1f(uTime, shaderT);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.finish(); // force GPU to complete before we grab the frame
}

// ─── Live preview (free-running) ──────────────────────────
let previewStart = null;
let previewId    = null;
function preview(ts) {
  if (previewStart === null) previewStart = ts;
  const elapsed = (ts - previewStart) / 1000;
  renderFrame(elapsed * SHADER_SPEED);
  previewId = requestAnimationFrame(preview);
}

// ─── Frame-by-frame recording ─────────────────────────────
async function startRecording() {
  // Stop live preview
  if (previewId) { cancelAnimationFrame(previewId); previewId = null; }

  const btn = document.getElementById('btn');
  btn.disabled = true;
  btn.textContent = '● Recording…';
  document.getElementById('status').textContent =
    `Recording ${TOTAL_FRAMES} frames @ ${FPS} fps (${LOOP_SECONDS.toFixed(1)} s) at ${W}×${H}…`;
  document.getElementById('progressBar').style.width = '0%';

  // captureStream(0) = manual-frame mode — only captures when we call requestFrame()
  const stream = canvas.captureStream(0);
  const videoTrack = stream.getVideoTracks()[0];
  const chunks = [];

  // Prefer VP9, fall back to VP8
  let mimeType = 'video/webm;codecs=vp9';
  if (!MediaRecorder.isTypeSupported(mimeType)) {
    mimeType = 'video/webm;codecs=vp8';
  }

  const recorder = new MediaRecorder(stream, {
    mimeType,
    videoBitsPerSecond: VIDEO_BITRATE,
  });

  recorder.ondataavailable = (e) => {
    if (e.data.size > 0) chunks.push(e.data);
  };

  const recorderStopped = new Promise(resolve => { recorder.onstop = resolve; });
  recorder.start();

  // Render every frame at exact time steps (decoupled from real-time)
  for (let frame = 0; frame < TOTAL_FRAMES; frame++) {
    const t = frame * FRAME_DT * SHADER_SPEED;
    renderFrame(t);

    // Push this exact frame into the video stream
    if (videoTrack.requestFrame) {
      videoTrack.requestFrame();
    }

    // Update progress bar
    if (frame % 10 === 0 || frame === TOTAL_FRAMES - 1) {
      document.getElementById('progressBar').style.width =
        ((frame / TOTAL_FRAMES) * 100).toFixed(1) + '%';
    }

    // Yield to browser so MediaRecorder can consume the frame
    // Small delay ensures encoder keeps up and doesn't drop frames
    await new Promise(r => setTimeout(r, 8));
  }

  recorder.stop();
  await recorderStopped;

  // Download
  const blob = new Blob(chunks, { type: 'video/webm' });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href     = url;
  a.download = 'login-bg.webm';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);

  btn.disabled    = false;
  btn.textContent = '● Record Again';
  document.getElementById('status').textContent =
    `✓ Done — ${TOTAL_FRAMES} frames @ ${FPS} fps. Move login-bg.webm into public/`;
  document.getElementById('progressBar').style.width = '100%';

  // Resume live preview
  previewStart = null;
  previewId = requestAnimationFrame(preview);
}

// ─── Button binding ───────────────────────────────────────
document.getElementById('btn').addEventListener('click', startRecording);

// ─── Start live preview ───────────────────────────────────
previewId = requestAnimationFrame(preview);
</script>
</body>
</html>
